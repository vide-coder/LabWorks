## Реализация наследования
```cpp
class Top {
public:
    ~Top() = default;     
protected:
    virtual void greet() { std::cout << "Top\n"; }
private:
    int value = 10;
};

class Bottom : public Top {
    void greet() override { std::cout << "PublicDerived\n"; }
    void show() { std::cout << prot << '\n'; }
};
```
Базовый класс Top является родительским для дочернего класса Bottom. Это указано с помощью ":". 
Этот синтаксис означает наследование, т.е. Bottom обладает всеми свойствами класса Top, 
а публичные члены с модификатором override может даже переопределять, как это сделанно с методом greet().
private поле value не доступно наследнику, а переопеделение метода доступно только потомкам Top.
## Множественное наследование и неоднозначности
```cpp
struct A { void f() const { std::cout << "A::f\n"; } };
struct B { void f() const { std::cout << "B::f\n"; } };
struct Multi : public A, public B {};

// ромб: virtual-наследование
struct Left  : virtual public Top {};
struct Right : virtual public Top {};
struct Bottom : public Left, public Right {
    void greet() const override { std::cout << "Bottom\n"; }
};
```
Позволяет наследовать поведение сразу от нескольких базовых классов, однако приводит к проблеме ромба, из-за чего возникают неоднозначности (метод
greet не значет какой функционал переопределять), если разные базовые классы предоставляют одноимённые члены. Разрешается
рефакторингом интерфейсов или явным переопределением в производном. В общем, это плохая практика и так делать не стоит,
если не хочется проблем со сложной и не гибкой иерархией, где поменяв что-то внизу иерахии, придется менять всех наследников. 

---

## Композиция vs Наследование

* Композиция (`has-a`) предпочтительна в большинстве случаев, так как позволяет реализовать схожий с наследованием функционал, но при этом упрощает инкапсуляцию и тестирование.
* Наследование (`is-a`) уместно использовать только при реальной иерархии типов И необходимости полиморфизма. Если одно из условий не выполняется, то в этом инструменте нет смысла.
